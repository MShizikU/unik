"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.regexFromString = exports.isOrdered = exports.getIntersectionLength = exports.buildSubjectVisitor = exports.buildVisitorObject = void 0;
const ref_utils_1 = require("../../../ref-utils");
const asserts_1 = require("./asserts");
function buildVisitorObject(subject, context, subjectVisitor) {
    if (!context) {
        return { [subject]: subjectVisitor };
    }
    let currentVisitorLevel = {};
    const visitor = currentVisitorLevel;
    for (let index = 0; index < context.length; index++) {
        const node = context[index];
        if (context.length === index + 1 && node.type === subject) {
            // Visitors don't work properly for the same type nested nodes, so
            // as a workaround for that we don't create separate visitor for the last element
            // which is the same as subject;
            // we will check includes/excludes it in the last visitor.
            continue;
        }
        const matchParentKeys = node.matchParentKeys;
        const excludeParentKeys = node.excludeParentKeys;
        if (matchParentKeys && excludeParentKeys) {
            throw new Error(`Both 'matchParentKeys' and 'excludeParentKeys' can't be under one context item`);
        }
        if (matchParentKeys || excludeParentKeys) {
            currentVisitorLevel[node.type] = {
                skip: (_value, key) => {
                    if (matchParentKeys) {
                        return !matchParentKeys.includes(key);
                    }
                    if (excludeParentKeys) {
                        return excludeParentKeys.includes(key);
                    }
                },
            };
        }
        else {
            currentVisitorLevel[node.type] = {};
        }
        currentVisitorLevel = currentVisitorLevel[node.type];
    }
    currentVisitorLevel[subject] = subjectVisitor;
    return visitor;
}
exports.buildVisitorObject = buildVisitorObject;
function buildSubjectVisitor(properties, asserts, context) {
    return (node, { report, location, rawLocation, key, type, resolve, rawNode }) => {
        var _a;
        // We need to check context's last node if it has the same type as subject node;
        // if yes - that means we didn't create context's last node visitor,
        // so we need to handle 'matchParentKeys' and 'excludeParentKeys' conditions here;
        if (context) {
            const lastContextNode = context[context.length - 1];
            if (lastContextNode.type === type.name) {
                const matchParentKeys = lastContextNode.matchParentKeys;
                const excludeParentKeys = lastContextNode.excludeParentKeys;
                if (matchParentKeys && !matchParentKeys.includes(key)) {
                    return;
                }
                if (excludeParentKeys && excludeParentKeys.includes(key)) {
                    return;
                }
            }
        }
        if (properties) {
            properties = Array.isArray(properties) ? properties : [properties];
        }
        for (const assert of asserts) {
            const currentLocation = assert.name === 'ref' ? rawLocation : location;
            if (properties) {
                for (const property of properties) {
                    // we can have resolvable scalar so need to resolve value here.
                    const value = ref_utils_1.isRef(node[property]) ? (_a = resolve(node[property])) === null || _a === void 0 ? void 0 : _a.node : node[property];
                    runAssertion({
                        values: value,
                        rawValues: rawNode[property],
                        assert,
                        location: currentLocation.child(property),
                        report,
                    });
                }
            }
            else {
                const value = assert.name === 'ref' ? rawNode : Object.keys(node);
                runAssertion({
                    values: Object.keys(node),
                    rawValues: value,
                    assert,
                    location: currentLocation,
                    report,
                });
            }
        }
    };
}
exports.buildSubjectVisitor = buildSubjectVisitor;
function getIntersectionLength(keys, properties) {
    const props = new Set(properties);
    let count = 0;
    for (const key of keys) {
        if (props.has(key)) {
            count++;
        }
    }
    return count;
}
exports.getIntersectionLength = getIntersectionLength;
function isOrdered(value, options) {
    const direction = options.direction || options;
    const property = options.property;
    for (let i = 1; i < value.length; i++) {
        let currValue = value[i];
        let prevVal = value[i - 1];
        if (property) {
            if (!value[i][property] || !value[i - 1][property]) {
                return false; // property doesn't exist, so collection is not ordered
            }
            currValue = value[i][property];
            prevVal = value[i - 1][property];
        }
        const result = direction === 'asc' ? currValue >= prevVal : currValue <= prevVal;
        if (!result) {
            return false;
        }
    }
    return true;
}
exports.isOrdered = isOrdered;
function runAssertion({ values, rawValues, assert, location, report }) {
    const lintResult = asserts_1.asserts[assert.name](values, assert.conditions, location, rawValues);
    if (!lintResult.isValid) {
        report({
            message: assert.message || `The ${assert.assertId} doesn't meet required conditions`,
            location: lintResult.location || location,
            forceSeverity: assert.severity,
            suggest: assert.suggest,
            ruleId: assert.assertId,
        });
    }
}
function regexFromString(input) {
    const matches = input.match(/^\/(.*)\/(.*)|(.*)/);
    return matches && new RegExp(matches[1] || matches[3], matches[2]);
}
exports.regexFromString = regexFromString;
