"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfig = exports.findConfig = exports.CONFIG_FILE_NAMES = exports.loadConfig = void 0;
const fs = require("fs");
const path = require("path");
const redocly_1 = require("../redocly");
const utils_1 = require("../utils");
const config_1 = require("./config");
const utils_2 = require("./utils");
const config_resolvers_1 = require("./config-resolvers");
function addConfigMetadata({ rawConfig, customExtends, configPath, }) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (customExtends !== undefined) {
            rawConfig.lint = rawConfig.lint || {};
            rawConfig.lint.extends = customExtends;
        }
        else if (utils_1.isEmptyObject(rawConfig)) {
            // TODO: check if we can add recommended here. add message here?
            // rawConfig.lint = { extends: ['recommended'], recommendedFallback: true };
        }
        const redoclyClient = new redocly_1.RedoclyClient();
        const tokens = yield redoclyClient.getTokens();
        if (tokens.length) {
            if (!rawConfig.resolve)
                rawConfig.resolve = {};
            if (!rawConfig.resolve.http)
                rawConfig.resolve.http = {};
            rawConfig.resolve.http.headers = [...((_a = rawConfig.resolve.http.headers) !== null && _a !== void 0 ? _a : [])];
            for (const item of tokens) {
                const domain = config_1.DOMAINS[item.region];
                rawConfig.resolve.http.headers.push({
                    matches: `https://api.${domain}/registry/**`,
                    name: 'Authorization',
                    envVariable: undefined,
                    value: item.token,
                }, 
                //support redocly.com domain for future compatibility
                ...(item.region === 'us'
                    ? [
                        {
                            matches: `https://api.redoc.ly/registry/**`,
                            name: 'Authorization',
                            envVariable: undefined,
                            value: item.token,
                        },
                    ]
                    : []));
            }
        }
        return config_resolvers_1.resolveConfig(rawConfig, configPath);
    });
}
function loadConfig(configPath = findConfig(), customExtends, processRawConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const rawConfig = yield getConfig(configPath);
        if (typeof processRawConfig === 'function') {
            yield processRawConfig(rawConfig);
        }
        return yield addConfigMetadata({
            rawConfig,
            customExtends,
            configPath,
        });
    });
}
exports.loadConfig = loadConfig;
exports.CONFIG_FILE_NAMES = ['redocly.yaml', 'redocly.yml', '.redocly.yaml', '.redocly.yml'];
function findConfig(dir) {
    if (!fs.hasOwnProperty('existsSync'))
        return;
    const existingConfigFiles = exports.CONFIG_FILE_NAMES.map((name) => dir ? path.resolve(dir, name) : name).filter(fs.existsSync);
    if (existingConfigFiles.length > 1) {
        throw new Error(`
      Multiple configuration files are not allowed. 
      Found the following files: ${existingConfigFiles.join(', ')}. 
      Please use 'redocly.yaml' instead.
    `);
    }
    return existingConfigFiles[0];
}
exports.findConfig = findConfig;
function getConfig(configPath = findConfig()) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!configPath || !utils_1.doesYamlFileExist(configPath))
            return {};
        try {
            const rawConfig = ((yield utils_1.loadYaml(configPath)) || {});
            return utils_2.transformConfig(rawConfig);
        }
        catch (e) {
            throw new Error(`Error parsing config file at '${configPath}': ${e.message}`);
        }
    });
}
exports.getConfig = getConfig;
