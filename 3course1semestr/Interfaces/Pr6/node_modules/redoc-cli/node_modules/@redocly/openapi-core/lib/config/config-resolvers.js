"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePreset = exports.resolveLint = exports.resolveApis = exports.resolvePlugins = exports.resolveConfig = void 0;
const path = require("path");
const colorette_1 = require("colorette");
const ref_utils_1 = require("../ref-utils");
const resolve_1 = require("../resolve");
const builtIn_1 = require("./builtIn");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const config_1 = require("./config");
function resolveConfig(rawConfig, configPath) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        if ((_b = (_a = rawConfig.lint) === null || _a === void 0 ? void 0 : _a.extends) === null || _b === void 0 ? void 0 : _b.some(utils_2.isNotString)) {
            throw new Error(`Error configuration format not detected in extends value must contain strings`);
        }
        const resolver = new resolve_1.BaseResolver(utils_1.getResolveConfig(rawConfig.resolve));
        const configExtends = (_d = (_c = rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.lint) === null || _c === void 0 ? void 0 : _c.extends) !== null && _d !== void 0 ? _d : ['recommended'];
        const recommendedFallback = !((_e = rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.lint) === null || _e === void 0 ? void 0 : _e.extends);
        const lintConfig = Object.assign(Object.assign({}, rawConfig === null || rawConfig === void 0 ? void 0 : rawConfig.lint), { extends: configExtends, recommendedFallback });
        const apis = yield resolveApis({
            rawConfig: Object.assign(Object.assign({}, rawConfig), { lint: lintConfig }),
            configPath,
            resolver,
        });
        const lint = yield resolveLint({
            lintConfig,
            configPath,
            resolver,
        });
        return new config_1.Config(Object.assign(Object.assign({}, rawConfig), { apis,
            lint }), configPath);
    });
}
exports.resolveConfig = resolveConfig;
function resolvePlugins(plugins, configPath = '') {
    if (!plugins)
        return [];
    // @ts-ignore
    const requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
    const seenPluginIds = new Map();
    return plugins
        .map((p) => {
        if (utils_2.isString(p) && ref_utils_1.isAbsoluteUrl(p)) {
            throw new Error(colorette_1.red(`We don't support remote plugins yet.`));
        }
        // TODO: resolve npm packages similar to eslint
        const pluginModule = utils_2.isString(p)
            ? requireFunc(path.resolve(path.dirname(configPath), p))
            : p;
        const id = pluginModule.id;
        if (typeof id !== 'string') {
            throw new Error(colorette_1.red(`Plugin must define \`id\` property in ${colorette_1.blue(p.toString())}.`));
        }
        if (seenPluginIds.has(id)) {
            const pluginPath = seenPluginIds.get(id);
            throw new Error(colorette_1.red(`Plugin "id" must be unique. Plugin ${colorette_1.blue(p.toString())} uses id "${colorette_1.blue(id)}" already seen in ${colorette_1.blue(pluginPath)}`));
        }
        seenPluginIds.set(id, p.toString());
        const plugin = Object.assign(Object.assign({ id }, (pluginModule.configs ? { configs: pluginModule.configs } : {})), (pluginModule.typeExtension ? { typeExtension: pluginModule.typeExtension } : {}));
        if (pluginModule.rules) {
            if (!pluginModule.rules.oas3 && !pluginModule.rules.oas2) {
                throw new Error(`Plugin rules must have \`oas3\` or \`oas2\` rules "${p}.`);
            }
            plugin.rules = {};
            if (pluginModule.rules.oas3) {
                plugin.rules.oas3 = utils_1.prefixRules(pluginModule.rules.oas3, id);
            }
            if (pluginModule.rules.oas2) {
                plugin.rules.oas2 = utils_1.prefixRules(pluginModule.rules.oas2, id);
            }
        }
        if (pluginModule.preprocessors) {
            if (!pluginModule.preprocessors.oas3 && !pluginModule.preprocessors.oas2) {
                throw new Error(`Plugin \`preprocessors\` must have \`oas3\` or \`oas2\` preprocessors "${p}.`);
            }
            plugin.preprocessors = {};
            if (pluginModule.preprocessors.oas3) {
                plugin.preprocessors.oas3 = utils_1.prefixRules(pluginModule.preprocessors.oas3, id);
            }
            if (pluginModule.preprocessors.oas2) {
                plugin.preprocessors.oas2 = utils_1.prefixRules(pluginModule.preprocessors.oas2, id);
            }
        }
        if (pluginModule.decorators) {
            if (!pluginModule.decorators.oas3 && !pluginModule.decorators.oas2) {
                throw new Error(`Plugin \`decorators\` must have \`oas3\` or \`oas2\` decorators "${p}.`);
            }
            plugin.decorators = {};
            if (pluginModule.decorators.oas3) {
                plugin.decorators.oas3 = utils_1.prefixRules(pluginModule.decorators.oas3, id);
            }
            if (pluginModule.decorators.oas2) {
                plugin.decorators.oas2 = utils_1.prefixRules(pluginModule.decorators.oas2, id);
            }
        }
        return plugin;
    })
        .filter(utils_2.notUndefined);
}
exports.resolvePlugins = resolvePlugins;
function resolveApis({ rawConfig, configPath = '', resolver, }) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { apis = {}, lint: lintConfig = {} } = rawConfig;
        let resolvedApis = {};
        for (const [apiName, apiContent] of Object.entries(apis || {})) {
            if ((_b = (_a = apiContent.lint) === null || _a === void 0 ? void 0 : _a.extends) === null || _b === void 0 ? void 0 : _b.some(utils_2.isNotString)) {
                throw new Error(`Error configuration format not detected in extends value must contain strings`);
            }
            const rawLintConfig = getMergedLintRawConfig(lintConfig, apiContent.lint);
            const apiLint = yield resolveLint({
                lintConfig: rawLintConfig,
                configPath,
                resolver,
            });
            resolvedApis[apiName] = Object.assign(Object.assign({}, apiContent), { lint: apiLint });
        }
        return resolvedApis;
    });
}
exports.resolveApis = resolveApis;
function resolveAndMergeNestedLint({ lintConfig, configPath = '', resolver = new resolve_1.BaseResolver(), }, parentConfigPaths = [], extendPaths = []) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        if (parentConfigPaths.includes(configPath)) {
            throw new Error(`Circular dependency in config file: "${configPath}"`);
        }
        const plugins = utils_1.getUniquePlugins(resolvePlugins([...((lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.plugins) || []), builtIn_1.defaultPlugin], configPath));
        const pluginPaths = (_a = lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.plugins) === null || _a === void 0 ? void 0 : _a.filter(utils_2.isString).map((p) => path.resolve(path.dirname(configPath), p));
        const resolvedConfigPath = ref_utils_1.isAbsoluteUrl(configPath)
            ? configPath
            : configPath && path.resolve(configPath);
        const extendConfigs = yield Promise.all(((_b = lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.extends) === null || _b === void 0 ? void 0 : _b.map((presetItem) => __awaiter(this, void 0, void 0, function* () {
            if (!ref_utils_1.isAbsoluteUrl(presetItem) && !path.extname(presetItem)) {
                return resolvePreset(presetItem, plugins);
            }
            const pathItem = ref_utils_1.isAbsoluteUrl(presetItem)
                ? presetItem
                : ref_utils_1.isAbsoluteUrl(configPath)
                    ? new URL(presetItem, configPath).href
                    : path.resolve(path.dirname(configPath), presetItem);
            const extendedLintConfig = yield loadExtendLintConfig(pathItem, resolver);
            return yield resolveAndMergeNestedLint({
                lintConfig: extendedLintConfig,
                configPath: pathItem,
                resolver: resolver,
            }, [...parentConfigPaths, resolvedConfigPath], extendPaths);
        }))) || []);
        const _d = utils_1.mergeExtends([
            ...extendConfigs,
            Object.assign(Object.assign({}, lintConfig), { plugins, extends: undefined, extendPaths: [...parentConfigPaths, resolvedConfigPath], pluginPaths }),
        ]), { plugins: mergedPlugins = [] } = _d, lint = __rest(_d, ["plugins"]);
        return Object.assign(Object.assign({}, lint), { extendPaths: (_c = lint.extendPaths) === null || _c === void 0 ? void 0 : _c.filter((path) => path && !ref_utils_1.isAbsoluteUrl(path)), plugins: utils_1.getUniquePlugins(mergedPlugins), recommendedFallback: lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.recommendedFallback, doNotResolveExamples: lintConfig === null || lintConfig === void 0 ? void 0 : lintConfig.doNotResolveExamples });
    });
}
function resolveLint(lintOpts, parentConfigPaths = [], extendPaths = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolvedLint = yield resolveAndMergeNestedLint(lintOpts, parentConfigPaths, extendPaths);
        return Object.assign(Object.assign({}, resolvedLint), { rules: resolvedLint.rules && groupLintAssertionRules(resolvedLint.rules) });
    });
}
exports.resolveLint = resolveLint;
function resolvePreset(presetName, plugins) {
    var _a;
    const { pluginId, configName } = utils_1.parsePresetName(presetName);
    const plugin = plugins.find((p) => p.id === pluginId);
    if (!plugin) {
        throw new Error(`Invalid config ${colorette_1.red(presetName)}: plugin ${pluginId} is not included.`);
    }
    const preset = (_a = plugin.configs) === null || _a === void 0 ? void 0 : _a[configName];
    if (!preset) {
        throw new Error(pluginId
            ? `Invalid config ${colorette_1.red(presetName)}: plugin ${pluginId} doesn't export config with name ${configName}.`
            : `Invalid config ${colorette_1.red(presetName)}: there is no such built-in config.`);
    }
    return preset;
}
exports.resolvePreset = resolvePreset;
function loadExtendLintConfig(filePath, resolver) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const fileSource = yield resolver.loadExternalRef(filePath);
            const rawConfig = utils_1.transformConfig(utils_2.parseYaml(fileSource.body));
            if (!rawConfig.lint) {
                throw new Error(`Lint configuration format not detected: "${filePath}"`);
            }
            return rawConfig.lint;
        }
        catch (error) {
            throw new Error(`Failed to load "${filePath}": ${error.message}`);
        }
    });
}
function getMergedLintRawConfig(configLint, apiLint) {
    const resultLint = Object.assign(Object.assign(Object.assign({}, configLint), apiLint), { rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.rules), oas2Rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas2Rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas2Rules), oas3_0Rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_0Rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_0Rules), oas3_1Rules: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_1Rules), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_1Rules), preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.preprocessors), oas2Preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas2Preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas2Preprocessors), oas3_0Preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_0Preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_0Preprocessors), oas3_1Preprocessors: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_1Preprocessors), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_1Preprocessors), decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.decorators), oas2Decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas2Decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas2Decorators), oas3_0Decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_0Decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_0Decorators), oas3_1Decorators: Object.assign(Object.assign({}, configLint === null || configLint === void 0 ? void 0 : configLint.oas3_1Decorators), apiLint === null || apiLint === void 0 ? void 0 : apiLint.oas3_1Decorators), recommendedFallback: (apiLint === null || apiLint === void 0 ? void 0 : apiLint.extends) ? false : configLint.recommendedFallback });
    return resultLint;
}
function groupLintAssertionRules(rules) {
    if (!rules) {
        return rules;
    }
    // Create a new record to avoid mutating original
    const transformedRules = {};
    // Collect assertion rules
    const assertions = [];
    for (const [ruleKey, rule] of Object.entries(rules)) {
        if (ruleKey.startsWith('assert/') && typeof rule === 'object' && rule !== null) {
            const assertion = rule;
            assertions.push(Object.assign(Object.assign({}, assertion), { assertionId: ruleKey.replace('assert/', '') }));
        }
        else {
            // If it's not an assertion, keep it as is
            transformedRules[ruleKey] = rule;
        }
    }
    if (assertions.length > 0) {
        transformedRules.assertions = assertions;
    }
    return transformedRules;
}
